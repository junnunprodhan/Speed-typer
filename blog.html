<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>blogs</title>
    <style>
        body{
            background-color: antiquewhite;
        }
        h1{
            color: red;
            text-align: center;
            font-weight: bold;
        }
        h3{
            color: blue;
            font-weight: bold;
            text-align: center;
        }
        ul{
            margin-left: 200px;
            margin-right: 200px;
        }
        
    </style>
</head>
<body>
<h1>All Blogs</h1>
<section>
    <div>
        <h3>1.Difference between LocalStorage and sessionStorage </h3>
        <ul>
            <li>sessionStorage maintains a separate storage area for each given origin that's available for the duration of the page session (as long as the browser is open, including page reloads and restores)</li>
            <li>localStorage does the same thing, but persists even when the browser is closed and reopened.</li>
            <li>The only difference is that localStorage has a different expiration time, sessionStorage will only be accessible while and by the window that created it is open.</li>
            <li>That is, the data stored in localStorage persists until explicitly deleted. Changes made are saved and available for all current and future visits to the site.</li>
            <li>That is, the data stored in localStorage persists until explicitly deleted. Changes made are saved and available for all current and future visits to the site.</li>
        </ul>
    </div>
    <div>
        <h3>Difference between global scope and block scope </h3>
        <ul></ul>
    </div>
    <div>
        <h3></h3>
        <ul>
            <li>Basically, the difference between function scope and block scope is that in a language that uses function scope, any variables declared within a function are visible anywhere within that same function. But with block scope, the visibility of variables is confined to any given block (whether it's an if statement, where/for loop, etc) enclosed by curly braces.</li>
            <li>
                Block scopes are what you get when you use if statements, for statements, and the like. You can also use them stand-alone with a simple begin-end curly braces {}, not to be confused with empty object literals.
            </li>
            <li>The var keyword behaves differently in function scopes and block scopes. A variable declared with var in a function scope can’t be accessed outside that function scope.</li>
            <li>A variable declared with var in a block scope is available outside of that block scope.</li>

        </ul>
    </div>
    <div>
        <h3>How to work even loop in javascript</h3>
        <ul>
            <li>
                The event loop is the secret behind JavaScript’s asynchronous programming. JS executes all operations on a single thread, but using a few smart data structures, it gives us the illusion of multi-threading. Let’s take a look at what happens on the back-end.
            </li>
            <li>
                The call stack is responsible for keeping track of all the operations in line to be executed. Whenever a function is finished, it is popped from the stack.
            </li>
            <li>
                The event queue is responsible for sending new functions to the stack for processing. It follows the queue data structure to maintain the correct sequence in which all operations should be sent for execution.
            </li>
            <li>
                Whenever an async function is called, it is sent to a browser API. These are APIs built into the browser. Based on the command received from the call stack, the API starts its own single-threaded operation.
                An example of this is the setTimeout method. When a setTimeout operation is processed in the stack, it is sent to the corresponding API which waits till the specified time to send this operation back in for processing.
                Where does it send the operation? The event queue. Hence, we have a cyclic system for running async operations in JavaScript. The language itself is single-threaded, but the browser APIs act as separate threads.
                The event loop facilitates this process; it constantly checks whether or not the call stack is empty. If it is empty, new functions are added from the event queue. If it is not, then the current function call is processed.
            </li>
        </ul>
    </div>
    <div>
        <h3>How find undefined in javascript</h3>
        <ul>
            <li>
                undefined is a property of the global object. That is, it is a variable in global scope. The initial value of undefined is the primitive value undefined.
            </li>
        </ul>
    </div>

</section>
</body>
</html>